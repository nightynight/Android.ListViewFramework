{
  "name": "Android.listviewframework",
  "tagline": "Android ListView万能适配器+下拉、上拉刷新数据",
  "body": "##一.万能适配器\r\n####项目中往往会用到多个ListView，传统的做法是为每个ListView写一个适配器，代码复用率太低。本文就先介绍如何打造一个万能适配器。\r\n先来看看一般的做法：\r\n主布局文件就一个ListView，Item的布局文件就四个TextView。Bean中有四个字段，对应四个TextView。\r\n下面是Adapter：\r\n```\r\npublic class MyAdapter extends BaseAdapter {\r\n    private LayoutInflater mInflater;\r\n    private List<Bean> mDatas;\r\n    public MyAdapter(Context context,List<Bean> datas){\r\n        mInflater=LayoutInflater.from(context);\r\n        mDatas=datas;\r\n    }\r\n    @Override\r\n    public int getCount() {\r\n        return mDatas.size();\r\n    }\r\n    @Override\r\n    public Object getItem(int position) {\r\n        return mDatas.get(position);\r\n    }\r\n    @Override\r\n    public long getItemId(int position) {\r\n        return position;\r\n    }\r\n    @Override\r\n    public View getView(int position, View convertView, ViewGroup parent) {\r\n        ViewHolder holder=null;\r\n        if(convertView==null){\r\n            convertView=mInflater.inflate(R.layout.item_listview,parent,false);\r\n            holder=new ViewHolder();\r\n            holder.mTitle=(TextView)convertView.findViewById(R.id.title);\r\n            holder.mDesc=(TextView)convertView.findViewById(R.id.desc);\r\n            holder.mTime=(TextView)convertView.findViewById(R.id.time);\r\n            holder.mPhone=(TextView)convertView.findViewById(R.id.phone);\r\n            convertView.setTag(holder);\r\n        }else {\r\n            holder=(ViewHolder)convertView.getTag();\r\n        }\r\n        final Bean bean=mDatas.get(position);\r\n        holder.mTitle.setText(bean.getTitle());\r\n        holder.mDesc.setText(bean.getDescribe());\r\n        holder.mTime.setText(bean.getTime());\r\n        holder.mPhone.setText(bean.getPhone());\r\n        return convertView;\r\n    }\r\n    private class ViewHolder{\r\n        TextView mTitle;\r\n        TextView mDesc;\r\n        TextView mTime;\r\n        TextView mPhone;\r\n    }\r\n}\r\n```\r\n要为Item写一个ViewHolder，还要重写四个方法，而主要的内容只在getView方法中。\r\n下面是MainActivity：\r\n```\r\npublic class MainActivity extends AppCompatActivity {\r\n    private LoadListView listView;\r\n    private List<Bean> datas=new ArrayList<Bean>();;\r\n    private MyAdapter adapter;\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        initDatas();\r\n        initView();\r\n    }\r\n    private void initDatas() {\r\n        datas.add(new Bean(\"Android万能适配器1\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器2\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器3\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器4\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器5\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器6\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器7\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器8\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器9\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器10\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        datas.add(new Bean(\"Android万能适配器11\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n        adapter=new MyAdapter(this,datas);\r\n    }\r\n    private void initView() {\r\n        listView=(LoadListView) findViewById(R.id.listView);\r\n        listView.setAdapter(adapter); //传统方法\r\n    }\r\n}\r\n```\r\n####下面用通用适配器来封装。\r\n先看一下封装的通用ViewHolder：\r\n```\r\npublic class ViewHolder {\r\n    private SparseArray<View> mViews;//SparseArray是特殊的Map，key为int型，value为object\r\n    private int mPosition;\r\n    private View mConvertView;\r\n    public int getPosition() {\r\n        return mPosition;\r\n    }\r\n    public void setPosition(int mPosition) {\r\n        this.mPosition = mPosition;\r\n    }\r\n    public ViewHolder(Context context, ViewGroup parent,int layoutId,int position){\r\n        this.mPosition=position;\r\n        this.mViews=new SparseArray<View>();\r\n        mConvertView= LayoutInflater.from(context).inflate(layoutId,parent,false);\r\n        mConvertView.setTag(this);\r\n    }\r\n    \r\n    //通过一个静态方法把holder暴露出去\r\n    public static ViewHolder get(Context context,View convertView,ViewGroup parent,int layoutId,int position){\r\n        if(convertView==null){\r\n            return new ViewHolder(context,parent,layoutId,position);\r\n        }else {\r\n            ViewHolder holder=(ViewHolder)convertView.getTag();\r\n            holder.mPosition=position;\r\n            return holder;\r\n        }\r\n    }\r\n    /**\r\n     * 通过viewID获取控件\r\n     * 通过holder.getView(viewId)就可以拿到对应的控件\r\n     * @param viewId\r\n     * @param <T>\r\n     * @return\r\n     */\r\n    public <T extends View> T getView(int viewId){\r\n        View view =mViews.get(viewId);\r\n        if (view==null){\r\n            view =mConvertView.findViewById(viewId);\r\n            mViews.put(viewId,view);\r\n        }\r\n        return (T)view;\r\n    }\r\n    public View getConvertView() {\r\n        return mConvertView;\r\n    }\r\n}\r\n```\r\n然后是通用适配器：\r\n```\r\npublic abstract class CommonAdapter<T> extends BaseAdapter {\r\n    protected LayoutInflater mInflater;\r\n    protected List<T> mDatas;\r\n    protected Context mContext;\r\n    public CommonAdapter(Context context, List<T> datas){\r\n        this.mInflater=LayoutInflater.from(context);\r\n        this.mDatas=datas;\r\n        this.mContext=context;\r\n    }\r\n    public void onDateChange(List<T> mDatas) {\r\n        this.mDatas = mDatas;\r\n        this.notifyDataSetChanged();\r\n    }\r\n    @Override\r\n    public int getCount() {\r\n        return mDatas.size();\r\n    }\r\n    @Override\r\n    public T getItem(int position) {\r\n        return mDatas.get(position);\r\n    }\r\n    @Override\r\n    public long getItemId(int position) {\r\n        return position;\r\n    }\r\n    @Override\r\n    public View getView(int position, View convertView, ViewGroup parent) {\r\n        ViewHolder holder=ViewHolder.get(mContext,convertView,parent,R.layout.item_listview,position);\r\n        convert(holder,getItem(position));\r\n        return holder.getConvertView();\r\n    }\r\n    //通过一个抽象方法，把主要的代码暴露给用户在自己的类中实现\r\n    public abstract void convert(ViewHolder holder,T t);\r\n}\r\n```\r\n接下来看怎么用我们封装的Adapter：\r\n```\r\npublic class MyAdapterWithCommon extends CommonAdapter<Bean> {\r\n    List<Integer> mPosition=new ArrayList<>();\r\n    public MyAdapterWithCommon(Context context, List<Bean> datas) {\r\n        super(context, datas);\r\n    }\r\n    @Override\r\n    public void convert(final ViewHolder holder, final Bean bean) {\r\n        //一般方法\r\n        ((TextView)holder.getView(R.id.title)).setText(bean.getTitle());\r\n        ((TextView)holder.getView(R.id.desc)).setText(bean.getDescribe());\r\n        ((TextView)holder.getView(R.id.time)).setText(bean.getTime());\r\n        ((TextView)holder.getView(R.id.phone)).setText(bean.getPhone());\r\n    }\r\n}\r\n```\r\n通过holder.getView(id)就可以拿到控件。\r\n接下来，我们看还能不能继续简化。可以把常用的控件相应的方法封装到ViewHolder中：\r\n```\r\n//下面为常用控件的辅助方法\r\n/**\r\n * 设置TextView的值\r\n * @param viewId\r\n * @param text\r\n * @return\r\n */\r\npublic ViewHolder setText(int viewId,String text){\r\n    TextView textView=getView(viewId);\r\n    textView.setText(text);\r\n    return this;\r\n}\r\n/**\r\n * 设置ImageView的图片\r\n * @param viewId\r\n * @param resId\r\n * @return\r\n */\r\npublic  ViewHolder setImageResource(int viewId,int resId){\r\n    ImageView view=getView(viewId);\r\n    view.setImageResource(resId);\r\n    return this;\r\n}\r\n//在这里写常用到的控件设置UI的方法\r\n//...\r\n```\r\n现在我们就可以在convert中这么使用：\r\n```\r\n//辅助方法\r\nholder.setText(R.id.title,bean.getTitle())\r\n        .setText(R.id.desc,bean.getDescribe())\r\n        .setText(R.id.time,bean.getTime())\r\n        .setText(R.id.phone,bean.getPhone());\r\n```\r\n也可以直接在Activity中通过内部类的方式来调用：\r\n```\r\nlistView.setAdapter(new CommonAdapter<Bean>(MainActivity.this,datas) {  //使用匿名内部类\r\n    @Override\r\n    public void convert(ViewHolder holder, Bean bean) {\r\n        holder.setText(R.id.title,bean.getTitle())\r\n                .setText(R.id.desc,bean.getDescribe())\r\n                .setText(R.id.time,bean.getTime())\r\n                .setText(R.id.phone,bean.getPhone());\r\n    }\r\n});\r\n```\r\n####接下来看两个ListView的常见问题：\r\n#####1.在ListView中加入checkBox或button后item无法点击\r\n    原因：Button、CheckBox等控件会抢占焦点\r\n    解决方案：\r\n            a.给Button或CheckBox设置android:focusable=\"false\"   \r\n            b.给item的layout节点添加android:descendantFocusability=\"blocksDescendants\"\r\n#####2.ListView的复用问题\r\n```\r\n//下面演示如何解决ListView复用导致的CheckBox选中问题\r\nfinal CheckBox checkBox=holder.getView(R.id.checkbox);\r\ncheckBox.setChecked(false);\r\nif ((mPosition.contains(holder.getPosition()))){\r\n    checkBox.setChecked(true);\r\n}\r\ncheckBox.setOnClickListener(new View.OnClickListener() {\r\n    @Override\r\n    public void onClick(View v) {\r\n        if(checkBox.isChecked())\r\n            mPosition.add((Integer)holder.getPosition());\r\n        else\r\n            mPosition.remove((Integer)holder.getPosition());\r\n    }\r\n});\r\n```\r\n##二.下拉、上拉刷新数据\r\n####首先写好header和footer的布局文件，分别为下拉和上拉时出现的布局。\r\nheader_layout.xml：\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:orientation=\"vertical\" >\r\n    <RelativeLayout\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:paddingBottom=\"10dp\"\r\n        android:paddingTop=\"10dp\" >\r\n        <LinearLayout\r\n            android:id=\"@+id/layout\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_centerInParent=\"true\"\r\n            android:gravity=\"center\"\r\n            android:orientation=\"vertical\" >\r\n            <TextView\r\n                android:id=\"@+id/tip\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:textColor=\"#777\"\r\n                android:text=\"下拉可以刷新！\" />\r\n            <TextView\r\n                android:id=\"@+id/lastupdate_time\"\r\n                android:textColor=\"#aaa\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\" />\r\n        </LinearLayout>\r\n        <ImageView\r\n            android:id=\"@+id/arrow\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"30dp\"\r\n            android:layout_toLeftOf=\"@id/layout\"\r\n            android:layout_marginRight=\"20dp\"\r\n            android:src=\"@drawable/pull_to_refresh_arrow\" />\r\n        <ProgressBar\r\n            android:id=\"@+id/progress\"\r\n            style=\"?android:attr/progressBarStyleSmall\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_toLeftOf=\"@id/layout\"\r\n            android:layout_marginRight=\"20dp\"\r\n            android:visibility=\"gone\" />\r\n    </RelativeLayout>\r\n</LinearLayout>\r\n```\r\nfooter_layout.xml：\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:orientation=\"vertical\" android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\">\r\n    <LinearLayout\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:id=\"@+id/load_layout\"\r\n        android:orientation=\"horizontal\"\r\n        android:gravity=\"center\"\r\n        android:padding=\"10dp\">\r\n        <ProgressBar\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            style=\"?android:attr/progressBarStyleSmall\"/>\r\n        <TextView\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"正在加载...\"/>\r\n    </LinearLayout>\r\n</LinearLayout>\r\n```\r\n新建一个类，继承ListView类和OnScrollListener接口：\r\n```\r\npublic class LoadListView extends ListView implements AbsListView.OnScrollListener {\r\n}\r\n```\r\n重写接口方法：\r\n```\r\nint scrollState;//ListView的当前滚动状态\r\nint firstVisibleItem;//第一个可见的Item\r\nint lastVisibleItem;//最后一个可见的Item\r\nint totalItemCount;//item的总数\r\n@Override\r\npublic void onScroll(AbsListView absListView, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\r\n    this.lastVisibleItem=firstVisibleItem+visibleItemCount;\r\n    this.totalItemCount=totalItemCount;\r\n    this.firstVisibleItem=firstVisibleItem;\r\n}\r\n@Override\r\npublic void onScrollStateChanged(AbsListView absListView, int scrollState) {\r\n    this.scrollState=scrollState;\r\n}\r\n```\r\n三个构造方法：\r\n```\r\n//三个构造方法\r\npublic LoadListView(Context context) {\r\n    super(context);\r\n    initView(context);\r\n}\r\npublic LoadListView(Context context, AttributeSet attrs) {\r\n    super(context, attrs);\r\n    initView(context);\r\n}\r\npublic LoadListView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n    super(context, attrs, defStyleAttr);\r\n    initView(context);\r\n}\r\n```\r\n下面是initView方法：\r\n```\r\nView header;//头部布局\r\nint headerHeight;\r\nboolean isLoadNewestDataReady=false;//是否准备好加载最新数据，当在最顶端按下时即为准备好了\r\nint state;//当前的状态\r\nfinal int NONE=0;//正常状态\r\nfinal int PULL=1;//提示下拉状态，显示下拉可以刷新\r\nfinal int RELESE=2;//提示释放状态，显示松开可以刷新\r\nfinal int REFLASHING=3;//提示正在刷新状态，显示正在刷新\r\nView footer;//底部布局\r\nint footerHeight;\r\nboolean isLoadMoreDataReady=false;//是否准备好加载更多数据，当在最底端按下时即为准备好了\r\nboolean isLoadingMoreData=false;//是否正在加载更多数据\r\n/**\r\n * 初始化界面，把header_layout和footer_layout加载到avtivity_main布局，通过设置topPadding和bottomPadding来隐藏header和footer\r\n * @param context\r\n */\r\nprivate void initView(Context context){\r\n    LayoutInflater inflater=LayoutInflater.from(context);\r\n    header=inflater.inflate(R.layout.header_layout,null);\r\n    measureView(header);//测量\r\n    headerHeight = header.getMeasuredHeight();//拿到子控件的高\r\n    setTopPadding(-headerHeight);\r\n    this.addHeaderView(header);\r\n    footer=inflater.inflate(R.layout.footer_layout,null);\r\n    measureView(footer);\r\n    footerHeight=footer.getMeasuredHeight();\r\n    setBottomPadding(-footerHeight);\r\n    this.addFooterView(footer);\r\n    this.setOnScrollListener(this); //设置滚动监听器\r\n}\r\n```\r\n下面是measureView方法：\r\n```\r\n/**\r\n * 测量，通知父布局，占用的宽、高\r\n * @param view\r\n */\r\nprivate void measureView(View view) {\r\n    ViewGroup.LayoutParams p = view.getLayoutParams();\r\n    if (p == null) {\r\n        p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\r\n                ViewGroup.LayoutParams.WRAP_CONTENT);\r\n    }\r\n    int width = ViewGroup.getChildMeasureSpec(0, 0, p.width);\r\n    int height;\r\n    int tempHeight = p.height;\r\n    if (tempHeight > 0) {\r\n        height = MeasureSpec.makeMeasureSpec(tempHeight, MeasureSpec.EXACTLY);\r\n    } else {\r\n        height = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\r\n    }\r\n    view.measure(width, height);\r\n}\r\n```\r\nsetTopPadding方法和satBottomPadding方法：\r\n```\r\n/**\r\n * 设置header的topPadding，控制header的显示\r\n * @param topPadding\r\n */\r\nprivate void setTopPadding(int topPadding) {\r\n    header.setPadding(header.getPaddingLeft(), topPadding,\r\n            header.getPaddingRight(), header.getPaddingBottom());\r\n    header.invalidate();\r\n}\r\n/**\r\n * 设置footer的bottomPadding，控制footer的显示\r\n * @param bottomPadding\r\n */\r\nprivate  void setBottomPadding(int bottomPadding) {\r\n    footer.setPadding(footer.getPaddingLeft(), footer.getPaddingTop(),\r\n            footer.getPaddingRight(), bottomPadding);\r\n    footer.invalidate();\r\n}\r\n```\r\n下面是onTouchEvent方法，主要的手指操作逻辑都放在这：\r\n```\r\nint startY;//手指按下时的Y坐标\r\n@Override\r\npublic boolean onTouchEvent(MotionEvent ev) {\r\n    switch (ev.getAction()){\r\n        case MotionEvent.ACTION_DOWN://手指按下\r\n            startY= (int) ev.getY();//获取手指按下的Y坐标\r\n            if (firstVisibleItem==0){//下拉刷新\r\n                isLoadNewestDataReady=true;\r\n            }\r\n            else if (totalItemCount==lastVisibleItem){//上拉加载更多\r\n                isLoadMoreDataReady=true;\r\n            }\r\n            break;\r\n        case MotionEvent.ACTION_MOVE://手指在屏幕上移动\r\n            onMove(ev);\r\n            break;\r\n        case MotionEvent.ACTION_UP://手指离开屏幕\r\n            if (state == RELESE) {\r\n                state = REFLASHING;\r\n                reflashViewByState();\r\n                // 加载最新数据；\r\n                LoadNewestAsyncTask loadNewestAsyncTask=new LoadNewestAsyncTask();\r\n                loadNewestAsyncTask.execute();\r\n            } else if(state!=REFLASHING) {\r\n                state = NONE;\r\n                isLoadNewestDataReady = false;\r\n                reflashViewByState();\r\n            }\r\n            break;\r\n    }\r\n    return super.onTouchEvent(ev);\r\n}\r\n```\r\n下面是onMove方法：\r\n```\r\n/**\r\n * 移动过程操作\r\n * @param ev\r\n */\r\nprivate void onMove(MotionEvent ev){\r\n    //下拉刷新\r\n    if(isLoadNewestDataReady){\r\n        int tempY= (int) ev.getY();\r\n        int space=tempY-startY;//space>0说明向下滑动\r\n        int topPadding=space-headerHeight;\r\n        switch (state){\r\n            case NONE:\r\n                if(space>0)\r\n                    state=PULL;\r\n                reflashViewByState();\r\n                break;\r\n            case PULL:\r\n                setTopPadding(topPadding);\r\n                if(space>headerHeight+200 && scrollState==SCROLL_STATE_TOUCH_SCROLL){\r\n                    state=RELESE;\r\n                    reflashViewByState();\r\n                }else if(space<=0){\r\n                    state=NONE;\r\n                    isLoadNewestDataReady=false;\r\n                    reflashViewByState();\r\n                }\r\n                break;\r\n            case RELESE:\r\n                if(space<headerHeight+200 && space>0){\r\n                    state=PULL;\r\n                    reflashViewByState();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    //上拉获取更多数据\r\n    if (isLoadMoreDataReady) {\r\n        setBottomPadding(footer.getPaddingTop());\r\n        int tempY = (int) ev.getY();\r\n        int space = startY - tempY;//space>0说明向上滑动\r\n        if (space > 100 && !isLoadingMoreData) {//如果上滑距离足够，且当前没有在加载数据\r\n            isLoadingMoreData = true;\r\n            //加载更多\r\n            LoadMoreAsyncTask loadMoreAsyncTask=new LoadMoreAsyncTask();\r\n            loadMoreAsyncTask.execute();\r\n        }\r\n    }\r\n}\r\n```\r\nreflashViewByState方法用来根据当前状态更新header的显示：\r\n```\r\n/**\r\n * 根据下拉当前状态，改变界面显示；\r\n */\r\nprivate void reflashViewByState() {\r\n    TextView tip = (TextView) header.findViewById(R.id.tip);\r\n    ImageView arrow = (ImageView) header.findViewById(R.id.arrow);\r\n    ProgressBar progress = (ProgressBar) header.findViewById(R.id.progress);\r\n    RotateAnimation anim = new RotateAnimation(0, 180,\r\n            RotateAnimation.RELATIVE_TO_SELF, 0.5f,\r\n            RotateAnimation.RELATIVE_TO_SELF, 0.5f);\r\n    anim.setDuration(500);\r\n    anim.setFillAfter(true);\r\n    RotateAnimation anim1 = new RotateAnimation(180, 0,\r\n            RotateAnimation.RELATIVE_TO_SELF, 0.5f,\r\n            RotateAnimation.RELATIVE_TO_SELF, 0.5f);\r\n    anim1.setDuration(500);\r\n    anim1.setFillAfter(true);\r\n    switch (state) {\r\n        case NONE:\r\n            arrow.clearAnimation();\r\n            setTopPadding(-headerHeight);\r\n            break;\r\n        case PULL:\r\n            arrow.setVisibility(View.VISIBLE);\r\n            progress.setVisibility(View.GONE);\r\n            tip.setText(\"下拉可以刷新！\");\r\n            arrow.clearAnimation();\r\n            arrow.setAnimation(anim1);\r\n            break;\r\n        case RELESE:\r\n            arrow.setVisibility(View.VISIBLE);\r\n            progress.setVisibility(View.GONE);\r\n            tip.setText(\"松开可以刷新！\");\r\n            arrow.clearAnimation();\r\n            arrow.setAnimation(anim);\r\n            break;\r\n        case REFLASHING:\r\n            setTopPadding(50);\r\n            arrow.setVisibility(View.GONE);\r\n            progress.setVisibility(View.VISIBLE);\r\n            tip.setText(\"正在刷新...\");\r\n            arrow.clearAnimation();\r\n            break;\r\n    }\r\n}\r\n```\r\n获取数据放在onLoadNewest和onLoadMore方法中，这两个方法需要用户自己写，所以用一个接口，把这两个方法暴露出去：\r\n```\r\n/**\r\n * 加载数据的回调接口，暴露给用户，在这个方法中刷新列表\r\n * 重写方法时只需获取数据，把数据添加到List中即可\r\n */\r\npublic interface ILoadListener{\r\n    public void onLoadMore();\r\n    public void onLoadNewest();\r\n}\r\n```\r\n还需要一个接口的set方法把接口传进来：\r\n```\r\nILoadListener iLoadListener;\r\npublic void setInterface(ILoadListener iLoadListener){\r\n    this.iLoadListener = iLoadListener;\r\n}\r\n```\r\n在两个AsyncTask中获取数据刷新界面：\r\n```\r\n//把获取最新数据放在AsyncTask中\r\nclass LoadNewestAsyncTask extends AsyncTask<Void,Void,Void> {\r\n    @Override\r\n    protected Void doInBackground(Void... params) {\r\n        iLoadListener.onLoadNewest();\r\n        return null;\r\n    }\r\n    @Override\r\n    protected void onPreExecute() {\r\n        super.onPreExecute();\r\n    }\r\n    @Override\r\n    /**\r\n     * 获取数据完成后更新界面，以及进行完成后的相关操作\r\n     */\r\n    protected void onPostExecute(Void aVoid) {\r\n        adapter.notifyDataSetChanged();//获取数据后刷新界面\r\n        loadNewsetComplete();\r\n        super.onPostExecute(aVoid);\r\n    }\r\n}\r\n//把获取更多数据放在AsyncTask中\r\nclass LoadMoreAsyncTask extends AsyncTask<Void,Void,Void> {\r\n    @Override\r\n    protected Void doInBackground(Void... params) {\r\n        iLoadListener.onLoadMore();\r\n        return null;\r\n    }\r\n    @Override\r\n    protected void onPreExecute() {\r\n        super.onPreExecute();\r\n    }\r\n    @Override\r\n    /**\r\n     * 获取数据完成后更新界面，以及进行完成后的相关操作\r\n     */\r\n    protected void onPostExecute(Void aVoid) {\r\n        adapter.notifyDataSetChanged();//获取数据后刷新界面\r\n        loadMoreComplete();\r\n        super.onPostExecute(aVoid);\r\n    }\r\n}\r\n```\r\nloadMoreComplete和loadNewsetComplete是完成后的相关操作：\r\n```\r\n//上拉完成\r\npublic void loadMoreComplete(){\r\n    setBottomPadding(-footerHeight);\r\n    isLoadingMoreData=false;\r\n    isLoadMoreDataReady=false;\r\n}\r\n//下拉完成\r\npublic void loadNewsetComplete(){\r\n    setTopPadding(-headerHeight);\r\n    isLoadNewestDataReady=false;\r\n    state=NONE;\r\n    //设置上次刷新时间\r\n    TextView lastupdatetime = (TextView) header.findViewById(R.id.lastupdate_time);\r\n    SimpleDateFormat format = new SimpleDateFormat(\"MM.dd hh:mm\");\r\n    Date date = new Date(System.currentTimeMillis());\r\n    String time = format.format(date);\r\n    lastupdatetime.setText(\"上次刷新时间：\"+time);\r\n}\r\n```\r\n在AsyncTask中用到了adapter.notifyDataSetChanged()方法，该方法用来数据更新后刷新界面。所以我们需要把adapter传进来，可以在setAdapter方法中把它传进来：\r\n```\r\nBaseAdapter adapter;\r\n//调用setAdapter时把adapter传进来\r\npublic void setAdapter(BaseAdapter adapter) {\r\n    this.adapter = adapter;\r\n    super.setAdapter(adapter);//别忘了调用父类的setAdapter方法\r\n}\r\n```\r\n到这里，我们的LoadListView已经写完了，接下来看看怎么用：\r\n首先在布局文件中把ListView换成我的写的LoadListView，然后在Activity中继承ILoadListener接口，重写onLoadMore和onLoadNewest方法，把接口传回LoadListView：\r\n```\r\nprivate void getLoadMoreData(){\r\n    datas.add(new Bean(\"Android万能适配器0\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n    datas.add(new Bean(\"Android万能适配器00\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n}\r\nprivate void getLoadNewData(){\r\n    datas.add(0,new Bean(\"Android万能适配器0\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n    datas.add(0,new Bean(\"Android万能适配器00\",\"Android打造万能的ListView和GridView适配器\",\"2016-8-31\",\"123456\"));\r\n}\r\n\r\n@Override\r\npublic void onLoadMore() {\r\n    try {\r\n        Thread.sleep(2000);//模拟网络延迟\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    getLoadMoreData();\r\n}\r\n@Override\r\npublic void onLoadNewest() {\r\n    // TODO Auto-generated method stub\r\n    try {\r\n        Thread.sleep(2000);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    getLoadNewData();\r\n}\r\n```\r\n在initView方法中把接口传过去：\r\n```\r\nprivate void initView() {\r\n    listView=(LoadListView) findViewById(R.id.listView);\r\n    listView.setInterface(this);\r\n    listView.setAdapter(adapter);   //使用万能适配器\r\n}\r\n```\r\n####到这，我们就把通用适配器和LoadListView封装好了，要在其他项目中只用，只要把CommonAdapter、ViewHolder、LoadListView和header_layout.xml、footer_layout.xml拷贝过去就可以了。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}